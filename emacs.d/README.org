#+title: Emacs configuration with Org Mode
#+author: Andrey Orst
#+email: andreyorst@gmail.com
#+setupfile: ./.org-defaults.org
#+startup: noinlineimages
#+property: header-args :tangle "./init.el" :results silent

[[file:.screenshot.png]]

* About this document
This is my Emacs configuration file in org mode. It is based on the
beautiful configuration by Andrey Orst, which can be found
[[https://github.com/andreyorst/dotfiles/tree/master/.config/emacs][here]], but I am going to modify it to suit my needs.

#+begin_src emacs-lisp
  ;;; init.el --- Emacs main configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Emacs config by Riccardo Pinosio.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Main config is located in .config/emacs/README.org
  ;;;
  ;;; Code:
#+end_src

* Initial Setup

Emacs starts fast, but as amount of packages grows it gets slower. The
init time is important  because I like to close it  when I'm not using
it. I'm not  closing and opening it  for every file, or  like every 15
minutes, but still, the faster it starts - the better for me.

** =early-init.el=
:properties:
:header-args+: :tangle "./early-init.el"
:end:
These settings are going into  different init file: =early-init.el=.  We
are going to use some speedup tricks from [[https://github.com/hlissner/doom-emacs][doom-emacs]] here.  But before
that, let's add top comment:

#+begin_src emacs-lisp
  ;;; early-init.el --- early configurations -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-
  ;;;
  ;;; Commentary:
  ;;; Emacs config by Riccardo Pinosio.
  ;;; This file was automatically generated by `org-babel-tangle'.
  ;;; Do not change this file.  Main config is located in .config/emacs/README.org
  ;;;
  ;;; Code:
#+end_src

*** Garbage Collection
The main problem  with Emacs startup is garbage  collection system. It
is invoked so many times on startup that it causes quite big impact on
startup time.   We're talking  /seconds/.  One can  raise limit  when to
trigger garbage collection, but this will end up in unpleasant editing
experience. So I'm  declaring these variables to  store default values
for the GC, to restore them after initialization is finished:

#+begin_src emacs-lisp
  (defvar aorst--gc-cons-threshold gc-cons-threshold)
  (defvar aorst--gc-cons-percentage gc-cons-percentage)
  (defvar aorst--file-name-handler-alist file-name-handler-alist)
#+end_src

Now we can tweak CG. We need to raise threshold to prevent it running:

#+begin_src emacs-lisp
  (setq-default gc-cons-threshold 402653184
                gc-cons-percentage 0.6
                inhibit-compacting-font-caches t
                message-log-max 16384
                file-name-handler-alist nil)
#+end_src

Then we need  a hook that restores initial  values once initialization
done:

#+begin_src emacs-lisp
  (add-hook 'after-init-hook
            (lambda ()
              (setq gc-cons-threshold aorst--gc-cons-threshold
                    gc-cons-percentage aorst--gc-cons-percentage
                    file-name-handler-alist aorst--file-name-handler-alist)))
#+end_src

*** Native Compiled Emacs Lisp
There's a  very interesting project  that I'm currently  using, called
[[http://akrl.sdf.org/gccemacs.html][gccemacs]]. It  provides a way to  compile Emacs Lisp into  native code,
thus making  Emacs much more  robust and  snappy. In order  to compile
everything that Emacs loads asynchronously we can set this variable to
=true=.

#+begin_src emacs-lisp
  (defvar comp-deferred-compilation)
  (setq comp-deferred-compilation t)
#+end_src

This way  I can compile  Emacs from source as  I usually do,  and then
continue using it as normal, and Emacs will do it's native compilation
in background for every loaded package. That's amazing!

*** User Interface
Prevent the glimpse of un-styled  Emacs by disabling these UI elements
early.

#+begin_src emacs-lisp
  (setq initial-frame-alist '((width . 170)
                              (height . 56)
                              (tool-bar-lines . 0)
                              (left-fringe . 0)
                              (right-fringe . 0)
                              (bottom-divider-width . 0)
                              (right-divider-width . 1))
        default-frame-alist initial-frame-alist)
#+end_src

Resizing frame is also expensive so we inhibit it, and latest patch to
Emacs  introduced =x-gtk-resize-child-frames=  variable  that fixes  the
issue  with  child frames  not  being  resized correctly  under  GNOME
Shell, so let's set it to =resize-mode=.

#+begin_src emacs-lisp
  (setq frame-inhibit-implied-resize t
        x-gtk-resize-child-frames 'resize-mode)
#+end_src

*** early =package.el= settings
=package.el= initialization is expensive so we disable it at startup:

#+begin_src emacs-lisp
  (defvar package--init-file-ensured)
  (setq package-enable-at-startup nil
        package--init-file-ensured t)
#+end_src

*** =(provide 'early-init)=
This concludes the =early-init.el= file.

#+begin_src emacs-lisp
  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

*** Loading =early-init.el= in Emacs 26 and earlier
:properties:
:header-args+: :tangle "./init.el"
:end:
Before Emacs  27 there were  no such thing  as =eraly-init.el=, so  if I
will use  older Emacs  with this configuration  it will  miss settings
that are done there. This code manually loads this file in such case:

#+begin_src emacs-lisp
  (unless (featurep 'early-init)
    (load (expand-file-name "early-init" user-emacs-directory)))
#+end_src

** =package.el=
To obtain plugins we need =package.el= package. Although this is builtin
and convenient,  it's also slow  and messy.  Instead of  using =package=
directly we will use =use-package= to manage package configurations.

Melpa is a  package repository, that I use to  get packages. Since all
packages that  I need can be  obtained from there, I  did not bothered
with different methods of installation.

#+begin_src emacs-lisp
  (defvar package-archives)
  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))
#+end_src

There's recent bug with downloading from elpa. This line fixes it:

#+begin_src emacs-lisp
  (when (version= emacs-version "26.2")
    (defvar gnutls-algorithm-priority)
    (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))
  (package-initialize)
#+end_src

Found this trick  [[https://genehack.blog/2020/04/a-bit-of-emacs-advice/][here]], but instead of using Boolean,  I've decided to
track time since last package refresh,  and use customize to store it.
This variable is  going to hold either =nil= or  date-time string.

#+begin_src emacs-lisp
  (defcustom package-last-refresh-date nil
    "Date and time when package lists have been refreshed.

  This variable is then used to check whether
  `package-refresh-contents' call is needed before calling
  `package-install'. Value of this varialbe is updated when
  `package-refresh-contents' is called.

  See `package-refresh-hour-threshold' for amount of time needed to
  trigger refresh."
    :type 'string
    :group 'package)
#+end_src

And we  need a variable that  holds amount of hours  that will trigger
the refresh:

#+begin_src emacs-lisp
  (defcustom package-automatic-refresh-threshold 24
    "Amount of hours since last `package-refresh-contents' call
  needed to trigger automatic refresh before calling `package-install'."
    :type 'number
    :group 'package)
#+end_src

This  advice first  checks if  our date-time  string exists,  and then
checks if there's more than 24 hours passed since last check.

#+begin_src emacs-lisp
  (define-advice package-install (:before (&rest _))
    (let ((seconds-per-hour 3600))
      (when (or (null package-last-refresh-date)
                (> (/ (float-time
                       (time-subtract (date-to-time (format-time-string "%Y-%m-%dT%H:%M"))
                                      (date-to-time package-last-refresh-date)))
                      seconds-per-hour)
                   package-automatic-refresh-threshold))
        (package-refresh-contents))))
#+end_src

Now all packages that  use =package-install= should periodically refresh
package  contents. In  order to  update time  we also  have to  advice
=package-refresh-contents=:

#+begin_src emacs-lisp
  (define-advice package-refresh-contents (:after (&rest _))
    (customize-save-variable 'package-last-refresh-date (format-time-string "%Y-%m-%dT%H:%M")))
#+end_src

This  variable gets  saved  in  your =custom=  file,  and is  persistent
through Emacs sessions.

** =use-package=
I use =use-package= to install, load  and configure my packages.  I find
this way very consistent and easy  to understand and maintain.  What I
like  about it  is that  it automatically  installs packages  on Emacs
startup. But unfortunately it can't be installed by itself, so we need
a way  to install  Use Package  in case  I load  this config  on fresh
system.

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
#+end_src

And =require= the package itself:

#+begin_src emacs-lisp
  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

This  way I  can  use =use-package=  automatically  install packages  at
startup, and  to configure  both built in  and external  packages, and
have  all   benefits  provided   by  =use-package=  such   as  deferring
configuration, encapsulating configuration, and so on.

* Defaults
Emacs is  old. I  understand that  back then  it could  be appropriate
decisions,  but as  of today  they are  completely obliterated  by the
passage of time.

** User Credentials
Let's set full name and e-mail address in case I would send e-mail from
Emacs, or some modes can use those automatically, like Org Mode:

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :ensure nil
    :custom
    (user-mail-address "andreyorst@gmail.com")
    (user-full-name "Andrey Orst"))
#+end_src

** Bell
I'm not  trying to  insult on anyone,  but usage of  the bell  is just
insane. It's  not 1980's, computers  have their own speakers  and rich
displays, why would anyone want  to use builtin speaker?  Why everyone
should know when I'm mistaken? Disable bell.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

** Backups
I don't  know who decided  that having backups  all over the  place is
good idea, but I don't think alike.

#+begin_src emacs-lisp
  (use-package files
    :ensure nil
    :custom
    (backup-by-copying t)
    (create-lockfiles nil)
    (backup-directory-alist '(("." . "~/.cache/emacs-backups")))
    (auto-save-file-name-transforms '((".*" "~/.cache/emacs-backups/" t))))
#+end_src

** Yes or No
For some  reason in some  situations Emacs asks  for typing =yes=  or =no=
explicitly, instead of accepting =y= or =n=. This can be fixed with this.

#+begin_src emacs-lisp
  (use-package subr
    :no-require t
    :ensure nil
    :init
    (fset 'yes-or-no-p 'y-or-n-p))
#+end_src

** Echo Keystrokes
Emacs displays pressed  key after some time but it's  too fast for me,
because I use Emacs on the phone  too, and the keyboard is a bit small
for lightning fast typing.

#+begin_src emacs-lisp
  (add-hook 'after-init-hook (lambda () (setq echo-keystrokes 5)))
#+end_src

** Mouse and Scrolling
I don't want menus on shift clicks:

#+begin_src emacs-lisp
  (global-unset-key (kbd "S-<down-mouse-1>"))
  (global-unset-key (kbd "<mouse-3>"))
  (global-set-key [mouse-3] menu-bar-edit-menu)
  (global-unset-key (kbd "S-<mouse-3>"))
#+end_src

I also  don't like how Emacs  handles scrolling, that it  speeds it up
and automatically scrolls horizontally. Also, changing =mouse-highlight=
to  =nil= value  disables highlighting  of hovered  item when  the point
moves which is kinda convenient when working with =flymake=.

#+begin_src emacs-lisp
  (setq-default mouse-wheel-progressive-speed nil
                auto-window-vscroll nil
                mouse-highlight nil)
#+end_src

** Tab character
Another default  setting that I kinda  dislike. Not that I'm  a fan of
spaces over tabs,  but I find that  there are much more  modes or even
languages that expect spaces, and not  tabs.  For instance, I need tab
characters only when I work with C code and Makefile rules.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Custom File and Disabled Commands
I  don't like  custom,  and  especially would  like  to  stop it  from
interfering to  my configuration  files, so lets  move it  to separate
file.

#+begin_src emacs-lisp
  (use-package cus-edit
    :ensure nil
    :custom
    (custom-file (expand-file-name "custom.el" user-emacs-directory))
    :init
    (load custom-file :noerror))
#+end_src

I also don't like that Emacs  has disabled commands, and enabling them
modifies  my =init.el=  that I  don't  modify myself.   Let's put  those
commands to =disabled.el= instead:

#+begin_src emacs-lisp
  (defvar disabled-commands (expand-file-name ".disabled.el" user-emacs-directory)
    "File to store disabled commands, that were enabled permamently.")
  (defadvice en/disable-command (around put-in-custom-file activate)
    "Put declarations in disabled.el."
    (let ((user-init-file disabled-commands))
      ad-do-it))
  (load disabled-commands :noerror)
#+end_src

** History
Another feature I  want is history between sessions. I'm  not sure why
it isn't default.

#+begin_src emacs-lisp
  (savehist-mode 1)
#+end_src

** Keyboard Layout
I use two keyboard layouts: =qwerty=  and =йцукен=, therefore I need a way
to switch between those without loosing  ability to use such chords as
=C-x=  which will  become  a =C-ч=  if  I select  Cyrillic  layout in  the
OS. Luckily for  me, Emacs provides a method to  switch layouts within
Emacs with =C-\=, so all common shortcuts will still work fine.

#+begin_src emacs-lisp
  (use-package mule-cmds
    :no-require t
    :ensure nil
    :custom
    (default-input-method 'russian-computer))
#+end_src

I'm  not   using  =russian-jcuken=   here  because  it   represents  the
"typewriter" layout with number-line inverted,  so to access numbers I
need to use Shift key. =russian-computer= doesn't have this problem.

** UTF8
Let's use =UTF8= if we can:

#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

** Default Major Mode
I would  like =*scratch*= buffer  to use  =fundamental= mode, so  it loads
faster.  Since  it's no  longer Emacs  Lisp interaction  buffer, let's
also remove initial message:

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :ensure nil
    :custom
    (initial-major-mode 'fundamental-mode)
    (initial-scratch-message ""))
#+end_src

** Selection
It is conveinient to delete selection by typing:

#+begin_src emacs-lisp
  (use-package delsel
    :ensure nil
    :init
    (delete-selection-mode t))
#+end_src

** Default Bindings and More
Configurations to built in =simple.el= module.

By default Emacs uses =kill-region= command on =C-w= shortcut. I find thisq
counterintuitiveq. GNU Readline uses =C-w=  to kill word backwards. Otherq
software  uses  this  shortcut  to kill  window.   I  prefer  Readline
approach.   Also I've  missed  =o=  and =O=  commands  from Kakoune.  With
=newline-below=  and  =newline-above= it  is  now  possible to  have  same
shortcuts in Emacs.

Emacs has nice  function, =zap-up-to-char= but for some  reason it's not
bound to any key. I find it more usable than =zap-to-char= so let's swap
those here.

Also,  I don't  want  my  files to  contain  trailing whitespaces,  so
=before-save-hook= hook will get rid of those automatically for me.

#+begin_src emacs-lisp
  (use-package simple
    :ensure nil
    :bind (("C-w" . aorst/kill-region-or-word)
           ("C-o" . aorst/newline-below)
           ("C-S-o" . aorst/newline-above)
           ("M-z" . zap-up-to-char)
           ("M-S-z" . zap-to-char))
    :hook (before-save . delete-trailing-whitespace)
    :init
    (defun aorst/kill-region-or-word (arg)
      (interactive "*p")
      (if (and transient-mark-mode
               mark-active)
          (kill-region (region-beginning) (region-end))
        (backward-kill-word arg)))
    (defun aorst/newline-below ()
      (interactive)
      (end-of-line)
      (newline-and-indent))
    (defun aorst/newline-above ()
      (interactive)
      (back-to-indentation)
      (newline-and-indent)
      (forward-line -1)
      (indent-according-to-mode)))
#+end_src

* Functions
This  section  describes  functions  I have  defined  for  use  inside
configurations  of various  packages, that  are general  enough to  be
placed in particular package  configuration. For example when function
is shared  between configurations  and some  configuration may  not be
loaded.

I prefix my  functions with =aorst/= and variables with  =aorst--= to make
those easier  to browse  with =ivy=  and to  explicitly define  that the
function is not a part of a particular package.

** =real-buffer-p=
This function decides if buffer  should be considered a "real" buffer,
e.g. a file-visiting buffer, or specific buffers that should behave as
file-visiting while not visiting a particular file, like =*scratch*=

#+begin_src emacs-lisp
  (defun aorst/real-buffer-p (&optional buffer)
    "Determines whether BUFFER is real."
    (let ((buffer-name (buffer-name buffer)))
      (or (and (not (minibufferp))
               (buffer-file-name buffer))
          (string-equal "*scratch*" buffer-name)
          (string-match-p ".~.*~" buffer-name)
          (string-match-p "FILE=/" buffer-name)
          (string-match-p "\*edit-indirect .*\*" buffer-name)
          (string-match-p "\*Org Src .*\*" buffer-name)
          (string-match-p "*eww*" buffer-name))))
#+end_src

** =real-buffer-setup=
If only  certain buffers  could +be so  grossly incandescent+  *have damn
fringes!* With Solaire Mode Emacs becomes way more like true GUI editor
with actual elements of user interface represented by different color,
but  these fringes  drive me  crazy.  That's  why I  wrote a  function
=aorst/real-buffer-setup=, that enables fringes only in buffers that are
affected by Solaire Mode:

#+begin_src emacs-lisp
  (defun aorst/real-buffer-setup (&rest _)
    "Wrapper around `set-window-fringes' function."
    (when window-system
      (let* ((window (selected-window))
             (buffer (window-buffer window)))
        (when (aorst/real-buffer-p buffer)
          (set-window-fringes window 8 8 t)
          (when (bound-and-true-p desktop-save-mode)
            (setq desktop-save-buffer t))))))
#+end_src

** =kill-when-no-processes=
This function  kills buffer which used  to have active process  but it
was killed. Should be used via hook or advice.

#+begin_src emacs-lisp
  (defun aorst/kill-when-no-processes (&rest _)
    "Kill buffer and its window when there's no processes left."
    (when (null (get-buffer-process (current-buffer)))
      (kill-buffer (current-buffer))))
#+end_src

** =escape=
One thing  that bothered  me is  that =C-g= is  universal way  to cancel
things in Emacs, gut you have to  be in exact window to cancel action.
This  function  intelligently tries  to  cancel  regardless of  active
window:

#+begin_src emacs-lisp
  (defun aorst/escape ()
    "Quit in current context.

  When there is an active minibuffer and we are not inside it close
  it.  When we are inside the minibuffer use the regular
  `minibuffer-keyboard-quit' which quits any active region before
  exiting.  When there is no minibuffer `keyboard-quit' unless we
  are defining or executing a macro."
    (interactive)
    (cond ((active-minibuffer-window)
           (if (minibufferp)
               (minibuffer-keyboard-quit)
             (abort-recursive-edit)))
          ((bound-and-true-p iedit-mode)
           (iedit-quit))
          (t
           (unless (or defining-kbd-macro
                       executing-kbd-macro)
             (keyboard-quit))))
    (message this-command))
  (global-set-key [remap keyboard-quit] #'aorst/escape)
#+end_src

** =font-installed-p=
This function checks if font is available on the system.

#+begin_src emacs-lisp
  (defun aorst/font-installed-p (font-name)
    "Check if font with FONT-NAME is available."
    (find-font (font-spec :name font-name)))
#+end_src

** =indent-buffer=
This function  is kinda  a way  to indent a  buffer by  using language
indentation rules provided by current mode. If there's a tool that can
properly format buffer it should be used instead of this function.

#+begin_src emacs-lisp
  (defun aorst/indent-buffer ()
    "Indent whole buffer."
    (interactive)
    (save-excursion
      (save-restriction
        (indent-region (point-min) (point-max)))))

  (global-set-key (kbd "C-c C-f") #'aorst/indent-buffer)
#+end_src

* User Interface
Packages that affect user interface.

** Splash Screen
Emacs displays splash screen once started  with no files. I don't need
it, so let's disable it.

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :ensure nil
    :custom
    (inhibit-splash-screen t))
#+end_src

** Menus and Tooltips
I don't need  all these tooltips, menus and  scrollbars. Emacs enables
all of those by default, so let's disable them as early as possible:

#+begin_src emacs-lisp
  (tooltip-mode -1)
  ; (menu-bar-mode -1)
  (fset 'menu-bar-open nil)

  (when window-system
    (scroll-bar-mode -1)
    (tool-bar-mode -1))
#+end_src

** Cursor Type
Also let's use bar cursor when in window system, which is visible only
in active window:

#+begin_src emacs-lisp
  (when window-system
    (setq-default cursor-type 'bar
                  cursor-in-non-selected-windows nil))
#+end_src

** Font
Here I want to use the fira code font as it's optimal for hacking and
I like the  ligatures. Adding some code to make  fira code the default
and to activate the ligatures.

#+begin_src emacs-lisp
(defun fira-code-mode--make-alist (list)
  "Generate prettify-symbols alist from LIST."
  (let ((idx -1))
    (mapcar
     (lambda (s)
       (setq idx (1+ idx))
       (let* ((code (+ #Xe100 idx))
          (width (string-width s))
          (prefix ())
          (suffix '(?\s (Br . Br)))
          (n 1))
     (while (< n width)
       (setq prefix (append prefix '(?\s (Br . Bl))))
       (setq n (1+ n)))
     (cons s (append prefix suffix (list (decode-char 'ucs code))))))
     list)))

(defconst fira-code-mode--ligatures
  '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\"
    "{-" "[]" "::" ":::" ":=" "!!" "!=" "!==" "-}"
    "--" "---" "-->" "->" "->>" "-<" "-<<" "-~"
    "#{" "#[" "##" "###" "####" "#(" "#?" "#_" "#_("
    ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*"
    "/**" "/=" "/==" "/>" "//" "///" "&&" "||" "||="
    "|=" "|>" "^=" "$>" "++" "+++" "+>" "=:=" "=="
    "===" "==>" "=>" "=>>" "<=" "=<<" "=/=" ">-" ">="
    ">=>" ">>" ">>-" ">>=" ">>>" "<*" "<*>" "<|" "<|>"
    "<$" "<$>" "<!--" "<-" "<--" "<->" "<+" "<+>" "<="
    "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<" "<~"
    "<~~" "</" "</>" "~@" "~-" "~=" "~>" "~~" "~~>" "%%"
    "x" ":" "+" "+" "*"))

(defvar fira-code-mode--old-prettify-alist)

(defun fira-code-mode--enable ()
  "Enable Fira Code ligatures in current buffer."
  (setq-local fira-code-mode--old-prettify-alist prettify-symbols-alist)
  (setq-local prettify-symbols-alist (append (fira-code-mode--make-alist fira-code-mode--ligatures) fira-code-mode--old-prettify-alist))
  (prettify-symbols-mode t))

(defun fira-code-mode--disable ()
  "Disable Fira Code ligatures in current buffer."
  (setq-local prettify-symbols-alist fira-code-mode--old-prettify-alist)
  (prettify-symbols-mode -1))

(define-minor-mode fira-code-mode
  "Fira Code ligatures minor mode"
  :lighter " Fira Code"
  (setq-local prettify-symbols-unprettify-at-point 'right-edge)
  (if fira-code-mode
      (fira-code-mode--enable)
    (fira-code-mode--disable)))

(defun fira-code-mode--setup ()
  "Setup Fira Code Symbols"
  (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol"))

(provide 'fira-code-mode)

;; we want fira code by default
(set-frame-font "Fira Code" nil t)
#+end_src

** Icons
=all-the-icons= package provides nice icons for Emacs via custom fonts.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :config
    (when (and (not (aorst/font-installed-p "all-the-icons"))
               (window-system))
      (all-the-icons-install-fonts t)))
#+end_src

I don't  use this package  directly yet,  but some other  packages do,
like DOOM Modeline or Treemacs.

** Theme
I'm using *doom-themes* package to make my Emacs look modern. This theme
collection  was developed  for [[https://github.com/hlissner/doom-emacs][DOOM  Emacs]],  and I  find these  themes
actually  great on  its own.   This package  contains nice  variant of
Atom-like One theme which I like, but it is also an amazingly well put
package, which defines colors for pretty much everything in Emacs.

#+begin_src emacs-lisp
  (use-package doom-themes
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :config
    (load-theme 'doom-one t)
    (set-face-attribute 'highlight nil
                        :foreground 'unspecified
                        :distant-foreground 'unspecified
                        :background 'unspecified))
#+end_src

** Fringe
I want fringes  to appear only in certain buffers  where I really need
them, so let's  disable it entirely on startup and  set them with some
hooks later.  But this adds another problem.  Emacs displays =$= sign at
the end of the  window if line is being truncated. Damn,  why it is so
hard  to  make  it  work  how  I want..   And  you  can't  simply  set
=standard-display-table= slot to empty space,  because it isn't ready on
Emacs init.

#+begin_src emacs-lisp
  (when window-system
    (use-package fringe
      :ensure nil
      :hook ((buffer-list-update
              window-configuration-change
              change-major-mode) . aorst/real-buffer-setup)
      :init
      (fringe-mode 0)
      (or standard-display-table
          (setq standard-display-table (make-display-table)))
      (set-display-table-slot standard-display-table 0 ?\s)))
#+end_src

** Modeline
I've tried bunch of different modelines:

- [[https://github.com/TheBB/spaceline][Spaceline]]
  Great modeline, but  I was experiencing slowdowns  in Emacs startup,
  and I like my Emacs to start fast.
- [[https://github.com/dbordak/telephone-line][Telephone Line]]
  Another good modeline, but I was lazy to configure it.
- [[https://github.com/milkypostman/powerline][Powerline]]
  This was first what I tried because I was using something similar in
  Vim. I don't remember why I dropped it.
- [[https://github.com/tarsius/moody][Moody]]
  Really lightweight  configuration for  default modeline,  which I've
  used for quite a some time.

They're all  great, but  I experienced some  troubles with  DOOM Theme
that I use, so  I've decided to try out DOOM  Modeline.  And turns out
it's great!

#+begin_src emacs-lisp
  (use-package doom-modeline
    :custom
    (doom-modeline-bar-width 3)
    (doom-modeline-major-mode-color-icon nil)
    (doom-modeline-buffer-color-icon nil)
    (doom-modeline-buffer-file-name-style 'relative-from-project)
    (doom-modeline-minor-modes t)
    (doom-modeline-height (floor (* (line-pixel-height) 1.8)))
    (find-file-visit-truename t)
    :config
    (let ((fg (face-attribute 'default :foreground))
          (bg (face-attribute 'mode-line :background))
          (fg-inactive (face-attribute 'font-lock-comment-face :foreground))
          (bg-inactive (face-attribute 'mode-line-inactive :background)))
      (dolist (face '(doom-modeline-buffer-modified
                      doom-modeline-buffer-minor-mode
                      doom-modeline-project-parent-dir
                      doom-modeline-project-dir
                      doom-modeline-project-root-dir
                      doom-modeline-highlight
                      doom-modeline-debug
                      doom-modeline-info
                      doom-modeline-warning
                      doom-modeline-urgent
                      doom-modeline-unread-number
                      doom-modeline-buffer-path
                      doom-modeline-bar
                      doom-modeline-bar-inactive
                      doom-modeline-panel
                      doom-modeline-buffer-major-mode
                      doom-modeline-buffer-file
                      doom-modeline-lsp-success
                      doom-modeline-lsp-warning
                      doom-modeline-lsp-error
                      doom-modeline-lsp-running
                      doom-modeline-persp-name
                      doom-modeline-battery-full
                      doom-modeline-battery-error
                      doom-modeline-battery-charging
                      doom-modeline-battery-critical
                      doom-modeline-battery-normal))
        (set-face-attribute face nil :foreground fg :weight 'normal))
      (set-face-attribute 'doom-modeline-buffer-file nil :weight 'semi-bold)
      (set-face-attribute 'doom-modeline-buffer-major-mode nil :weight 'semi-bold)
      (set-face-attribute 'doom-modeline-panel nil :background bg)
      (set-face-attribute 'doom-modeline-bar nil :background bg)
      (set-face-attribute 'doom-modeline-bar-inactive nil :background bg)
      (set-face-attribute 'mode-line-inactive nil :foreground fg-inactive :background bg-inactive))
    (doom-modeline-mode 1))
#+end_src

I  don't  find displaying  position  in  modeline really  great  idea,
because I need to move my eyes too much on big screen just to see what
line number  I'm currently  on. Also, let's  make modeline  little bit
bigger.  And remove that bevel thing.

#+begin_src emacs-lisp
  (setq-default column-number-mode t
                line-number-mode t
                size-indication-mode nil
                mode-line-position nil
                mode-line-percent-position nil
                mode-line-in-non-selected-windows nil)
  (unless (bound-and-true-p doom-modeline-mode)
    (set-face-attribute 'mode-line nil
                        :box (list :line-width 8
                                   :color (face-attribute 'mode-line :background))))
#+end_src

** Frame
Emacs uses  white titlebar, but  since I'm  using dark color  scheme I
want title bar  to be dark as  well. It is quite  difficult to achieve
this in GNOME  Shell, but I found  this code [[https://nicolas.petton.fr/blog/emacs-dark-window-decoration.html][on the internet]].  So if I
use =window-system=  I want this  function to run  during initialization
process, and when new frame is created.

#+begin_src emacs-lisp
  (when window-system
    (use-package frame
      :ensure nil
      :custom
      (window-divider-default-right-width 1)
      :config
      (window-divider-mode 1)
      (set-face-attribute 'window-divider nil
                          :foreground (face-attribute
                                       'mode-line-inactive :background))))
#+end_src

** Title
Emacs uses weird method of naming a window, I'd like to see a file I'm
currently working  on in the task  bar in case my  Emacs was minimized
for some reason.

#+begin_src emacs-lisp
  (setq-default frame-title-format '("%b — Emacs"))
#+end_src

** Treemacs
To make Emacs look more like  a traditional modern text editor we need
a file explorer.  Emacs has  builtin package for this, named =speedbar=,
but It uses external frame and has  so many features that I don't know
if I really need. With this package, and its supplement packages I can
have a consistent  filetree inside my Emacs frame. Which  is good. But
there's more:  DOOM Themes support  this package as well,  which means
that Treemacs will look just as great as DOOM themed Emacs!

#+begin_src emacs-lisp
  (when window-system
    (use-package treemacs
      :commands (treemacs-follow-mode
                 treemacs-filewatch-mode
                 treemacs-fringe-indicator-mode
                 treemacs-load-theme)
      :bind (("<f7>" . treemacs)
             ("<f8>" . treemacs-select-window)
             :map
             treemacs-mode-map
             ([C-tab] . aorst/treemacs-expand-all-projects))
      :hook ((after-init . aorst/treemacs-after-init-setup)
             (treemacs-mode . aorst/after-treemacs-setup)
             (treemacs-switch-workspace . aorst/treemacs-expand-all-projects)
             (treemacs-switch-workspace . treemacs-set-fallback-workspace)
             (treemacs-mode . aorst/treemacs-setup-title))
      :custom
      (treemacs-width 34)
      (treemacs-is-never-other-window t)
      (treemacs-space-between-root-nodes nil)
      (treemacs-indentation 2)
      :config
      (use-package treemacs-magit)
      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (treemacs-fringe-indicator-mode nil)
      (set-face-attribute 'treemacs-root-face nil
                          :foreground (face-attribute 'default :foreground)
                          :height 1.0
                          :weight 'normal)
      (defun aorst/treemacs-ignore (file _)
        (or (s-ends-with? ".elc" file)
            (s-ends-with? ".o" file)
            (s-ends-with? ".a" file)
            (string= file ".svn")))
      (add-to-list 'treemacs-ignored-file-predicates #'aorst/treemacs-ignore)
      (treemacs-create-theme "Atom"
        :config
        (progn
          (treemacs-create-icon
           :icon (format " %s\t"
                         (all-the-icons-octicon
                          "repo"
                          :v-adjust -0.1
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (root))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-down"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "file-directory"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (dir-open))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-right"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "file-directory"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (dir-closed))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-down"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "package"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (tag-open))
          (treemacs-create-icon
           :icon (format "%s\t%s\t"
                         (all-the-icons-octicon
                          "chevron-right"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal))
                         (all-the-icons-octicon
                          "package"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (tag-closed))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "tag"
                          :height 0.9
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (tag-leaf))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "flame"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (error))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "stop"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (warning))
          (treemacs-create-icon
           :icon (format "%s\t"
                         (all-the-icons-octicon
                          "info"
                          :height 0.75
                          :v-adjust 0.1
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (info))
          (treemacs-create-icon
           :icon (format "  %s\t"
                         (all-the-icons-octicon
                          "file-media"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("png" "jpg" "jpeg" "gif" "ico" "tif" "tiff" "svg" "bmp"
                        "psd" "ai" "eps" "indd" "mov" "avi" "mp4" "webm" "mkv"
                        "wav" "mp3" "ogg" "midi"))
          (treemacs-create-icon
           :icon (format "  %s\t"
                         (all-the-icons-octicon
                          "file-code"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("yml" "yaml" "sh" "zsh" "fish" "c" "h" "cpp" "cxx" "hpp"
                        "tpp" "cc" "hh" "hs" "lhs" "cabal" "py" "pyc" "rs" "el"
                        "elc" "clj" "cljs" "cljc" "ts" "tsx" "vue" "css" "html"
                        "htm" "dart" "java" "kt" "scala" "sbt" "go" "js" "jsx"
                        "hy" "json" "jl" "ex" "exs" "eex" "ml" "mli" "pp" "dockerfile"
                        "vagrantfile" "j2" "jinja2" "tex" "racket" "rkt" "rktl" "rktd"
                        "scrbl" "scribble" "plt" "makefile" "elm" "xml" "xsl" "rb"
                        "scss" "lua" "lisp" "scm" "sql" "toml" "nim" "pl" "pm" "perl"
                        "vimrc" "tridactylrc" "vimperatorrc" "ideavimrc" "vrapperrc"
                        "cask" "r" "re" "rei" "bashrc" "zshrc" "inputrc" "editorconfig"
                        "gitconfig"))
          (treemacs-create-icon
           :icon (format "  %s\t"
                         (all-the-icons-octicon
                          "book"
                          :v-adjust 0
                          :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("lrf" "lrx" "cbr" "cbz" "cb7" "cbt" "cba" "chm" "djvu"
                        "doc" "docx" "pdb" "pdb" "fb2" "xeb" "ceb" "inf" "azw"
                        "azw3" "kf8" "kfx" "lit" "prc" "mobi" "pkg" "opf" "txt"
                        "pdb" "ps" "rtf" "pdg" "xml" "tr2" "tr3" "oxps" "xps"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-text"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("md" "markdown" "rst" "log" "org" "txt"
                        "CONTRIBUTE" "LICENSE" "README" "CHANGELOG"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-binary"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("exe" "dll" "obj" "so" "o" "out"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-pdf"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("pdf"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-zip"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions ("zip" "7z" "tar" "gz" "rar" "tgz"))
          (treemacs-create-icon
           :icon (format "  %s\t" (all-the-icons-octicon
                                   "file-text"
                                   :v-adjust 0
                                   :face '(:inherit font-lock-doc-face :slant normal)))
           :extensions (fallback))))
      :init
      (defun aorst/treemacs-expand-all-projects (&optional _)
        "Expand all projects."
        (interactive)
        (save-excursion
          (treemacs--forget-last-highlight)
          (dolist (project (treemacs-workspace->projects (treemacs-current-workspace)))
            (-when-let (pos (treemacs-project->position project))
              (when (eq 'root-node-closed (treemacs-button-get pos :state))
                (goto-char pos)
                (treemacs--expand-root-node pos)))))
        (treemacs--maybe-recenter 'on-distance))
      (defun aorst/treemacs-variable-pitch-labels (&rest _)
        (dolist (face '(treemacs-file-face
                        treemacs-root-face
                        treemacs-tags-face
                        treemacs-directory-face
                        treemacs-directory-collapsed-face
                        treemacs-term-node-face
                        treemacs-help-title-face
                        treemacs-help-column-face
                        treemacs-git-added-face
                        treemacs-git-ignored-face
                        treemacs-git-renamed-face
                        treemacs-git-conflict-face
                        treemacs-git-modified-face
                        treemacs-git-unmodified-face
                        treemacs-git-untracked-face
                        treemacs-root-unreadable-face
                        treemacs-root-remote-face
                        treemacs-root-remote-unreadable-face
                        treemacs-root-remote-disconnected-face
                        treemacs-fringe-indicator-face
                        treemacs-on-failure-pulse-face
                        treemacs-on-success-pulse-face))
          (let ((faces (face-attribute face :inherit nil)))
            (set-face-attribute
             face nil :inherit
             `(variable-pitch ,@(delq 'unspecified (if (listp faces) faces (list faces))))))))
      (defun aorst/treemacs-after-init-setup ()
        "Set treemacs theme, open treemacs, and expand all projects."
        (treemacs-load-theme "Atom")
        (setq treemacs-collapse-dirs 0)
        (treemacs)
        (aorst/treemacs-expand-all-projects)
        (windmove-right))
      (defun aorst/after-treemacs-setup ()
        "Set treemacs buffer common settings."
        (setq tab-width 1
              mode-line-format nil
              line-spacing 5)
        (setq-local scroll-step 1)
        (setq-local scroll-conservatively 10000)
        (set-window-fringes nil 0 0 t)
        (aorst/treemacs-variable-pitch-labels))
      (defun aorst/treemacs-setup-fringes ()
        "Set treemacs buffer fringes."
        (set-window-fringes nil 0 0 t)
        (aorst/treemacs-variable-pitch-labels))
      (advice-add #'treemacs-select-window :after #'aorst/treemacs-setup-fringes)
      (defun aorst/treemacs-setup-title ()
        (let ((bg (face-attribute 'default :background))
              (fg (face-attribute 'default :foreground)))
          (face-remap-add-relative 'header-line
                                   :background bg :foreground fg
                                   :box `(:line-width ,(/ (line-pixel-height) 2) :color ,bg)))
        (setq header-line-format
              '((:eval
                 (let* ((text (treemacs-workspace->name (treemacs-current-workspace)))
                        (extra-align (+ (/ (length text) 2) 1))
                        (width (- (/ (window-width) 2) extra-align)))
                   (concat (make-string width ?\s) text))))))))
#+end_src

** Minions
This  package  implements   a  menu  that  lists   all  enabled  minor
modes. Emacs mode  line can become pretty long, so  this can be handy,
and perhaps I don't need to use =:diminish= everywhere anymore.

#+begin_src emacs-lisp
  (use-package minions
    :commands minions-mode
    :init (minions-mode 1))
#+end_src

** Uniquify
This package makes files with  identical names more distinguishable by
adding directory name in the buffer name.

#+begin_src emacs-lisp
  (use-package uniquify
    :ensure nil
    :custom (uniquify-buffer-name-style 'forward))
#+end_src

** Tabline
Starting  with Emacs  27  native tab  support is  present.  I want  to
customize tab appearance to match my theme.

#+begin_src emacs-lisp
  (unless (version< emacs-version "27")
    (use-package tab-line
      :ensure nil
      :hook (after-init . global-tab-line-mode)
      :config
      (defun tab-line-close-tab (&optional e)
        "Close the selected tab.
  If tab is presented in another window, close the tab by using `bury-buffer` function.
  If tab is uniq to all existing windows, kill the buffer with `kill-buffer` function.
  Lastly, if no tabs left in the window, it is deleted with `delete-window` function."
        (interactive "e")
        (let* ((posnp (event-start e))
               (window (posn-window posnp))
               (buffer (get-pos-property 1 'tab (car (posn-string posnp)))))
          (with-selected-window window
            (let ((tab-list (tab-line-tabs-window-buffers))
                  (buffer-list (flatten-list
                                (seq-reduce (lambda (list window)
                                              (select-window window t)
                                              (cons (tab-line-tabs-window-buffers) list))
                                            (window-list) nil))))
              (select-window window)
              (if (> (seq-count (lambda (b) (eq b buffer)) buffer-list) 1)
                  (progn
                    (if (eq buffer (current-buffer))
                        (bury-buffer)
                      (set-window-prev-buffers window (assq-delete-all buffer (window-prev-buffers)))
                      (set-window-next-buffers window (delq buffer (window-next-buffers))))
                    (unless (cdr tab-list)
                      (ignore-errors (delete-window window))))
                (and (kill-buffer buffer)
                     (unless (cdr tab-list)
                       (ignore-errors (delete-window window)))))))
          (force-mode-line-update)))

      (setq tab-line-new-tab-choice nil
            tab-line-close-button-show nil
            tab-line-new-button-show nil
            tab-line-separator nil
            tab-line-right-button (propertize (if (char-displayable-p ?▶) " ▶ " " > ")
                                              'keymap tab-line-right-map
                                              'mouse-face 'tab-line-highlight
                                              'help-echo "Click to scroll right")
            tab-line-left-button (propertize (if (char-displayable-p ?◀) " ◀ " " < ")
                                             'keymap tab-line-left-map
                                             'mouse-face 'tab-line-highlight
                                             'help-echo "Click to scroll left"))

      (let ((bg (if (facep 'solaire-default-face)
                    (face-attribute 'solaire-default-face :background)
                  (face-attribute 'default :background)))
            (fg (face-attribute 'default :foreground))
            (base (face-attribute 'mode-line :background))
            (box-width (/ (line-pixel-height) 2)))
        (set-face-attribute 'tab-line nil :background base :foreground fg :height 1.0 :inherit nil)
        (set-face-attribute 'tab-line-tab nil :foreground fg :background bg :box (list :line-width box-width :color bg) :weight 'normal :inherit nil)
        (set-face-attribute 'tab-line-tab-inactive nil :foreground fg :background base :box (list :line-width box-width :color base) :weight 'normal :inherit nil)
        (set-face-attribute 'tab-line-tab-current nil :foreground fg :background bg :box (list :line-width box-width :color bg) :weight 'normal :inherit nil))

      (dolist (mode '(ediff-mode
                      process-menu-mode
                      term-mode
                      vterm-mode))
        (add-to-list 'tab-line-exclude-modes mode))))
#+end_src

** Line Numbers
*display-line-numbers* mode is built in and provides line numbers on the
left  side of  the window,  which doesn't  lag. I  don't like  that it
changes width, so let's make it grow only, and calculate maximum width
on file open:

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :ensure nil
    :custom
    (display-line-numbers-grow-only t)
    (display-line-numbers-width-start t))
#+end_src

** Evil mode
I prefer Evil mode for input, so I am going to require that.

#+begin_src emacs-lisp
(use-package evil
  :ensure t ;; install the evil package if not installed
  :init ;; tweak evil's configuration before loading it
  (setq evil-search-module 'evil-search)
  (setq evil-ex-complete-emacs-commands nil)
  (setq evil-vsplit-window-right t)
  (setq evil-split-window-below t)
  (setq evil-shift-round nil)
  (setq evil-want-C-u-scroll t)
  :config ;; tweak evil after loading it
  (evil-mode))
#+end_src

* Languages
This section contains various  language specific settings and external
packages that provide language support.

** Org
Org  Mode is  a great  mode for  taking notes,  managing to-do  lists,
writing books, literate programming, and  many other things. I primary
use it for taking notes on different programming languages, and manage
my Emacs configuration with it.

#+begin_src emacs-lisp
  (use-package org
    :ensure nil
    :defines default-justification
    :hook ((org-mode . flyspell-mode)
           (org-mode . auto-fill-mode)
           (after-save . aorst/org-tangle-on-config-save)
           (org-babel-after-execute . aorst/org-update-inline-images)
           (org-mode . aorst/org-init-setup)
           (ediff-prepare-buffer . outline-show-all)
           ((org-capture-mode org-src-mode) . aorst/discard-history))
    :bind (("C-c a" . org-agenda)
           :map
           org-mode-map
           ("C-c l" . org-store-link))
    :custom
    (org-startup-with-inline-images nil)
    (org-tags-column -100)
    (org-startup-folded 'content)
    (org-hide-emphasis-markers t)
    (org-adapt-indentation nil)
    (org-hide-leading-stars t)
    (org-highlight-latex-and-related '(latex))
    (revert-without-query '(".*\.pdf"))
    (org-preview-latex-default-process 'dvisvgm)
    (org-src-fontify-natively t)
    (org-preview-latex-image-directory ".ltximg/")
    (org-latex-listings 'minted)
    (org-latex-pdf-process '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
                            ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")
                            ("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    (org-confirm-babel-evaluate nil)
    (org-imenu-depth 8)
    (org-log-done t)
    (org-agenda-files '("~/Tasks"))
    :config
    (use-package ox-latex
      :ensure nil)
    (use-package ox-hugo
      :after ox)
    (when (not (version<= org-version "9.1.9"))
      (use-package org-tempo
        :ensure nil))
    (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-+]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    (defun aorst/org-tangle-on-config-save ()
      "Tangle source code blocks when configuration file is saved."
      (when (string= buffer-file-name (file-truename (concat user-emacs-directory "README.org")))
        (org-babel-tangle)))
    (defun aorst/org-update-inline-images ()
      "Update inline images in Org-mode."
      (interactive)
      (when org-inline-image-overlays
        (org-redisplay-inline-images)))
    (defun aorst/org-init-setup ()
      "Set buffer local values."
      (setq default-justification 'full))
    (defun aorst/discard-history ()
      "Discard undo history of org src and capture blocks."
      (setq buffer-undo-list nil)
      (set-buffer-modified-p nil))
    (defvar minted-cache-dir
      (file-name-as-directory
       (expand-file-name ".minted/\\jobname"
                         temporary-file-directory)))
    (add-to-list 'org-latex-packages-alist
                 `(,(concat "cachedir=" minted-cache-dir)
                   "minted" nil))
    (add-to-list 'org-latex-logfiles-extensions "tex")
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((gnuplot . t)
       (scheme . t)))
    (add-to-list 'org-latex-classes
                 '("article"
                   "\\documentclass{article}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
    (defun aorst/org-update-latex-preview-background-color (&rest _)
      (setq-default
       org-format-latex-options
       (plist-put org-format-latex-options
                  :background
                  (face-attribute (or (cadr (assq 'default face-remapping-alist))
                                      'default)
                                  :background nil t))))
    (add-hook 'solaire-mode-hook #'aorst/org-update-latex-preview-background-color))
#+end_src

** Prog Mode
This isn't really a configuration of  Prog Mode itself, but some hooks
that change how  programming related modes behave. One  feature that I
think is really important, especially  when working with lisp code, is
ability  to see  matching bracket  when cursor  stands near  the other
bracket. So I enable it for every programming language.

#+begin_src emacs-lisp
  (use-package prog-mode
    :ensure nil
    :hook ((prog-mode . show-paren-mode)
           (prog-mode . display-line-numbers-mode)))
           ;; (prog-mode . hl-line-mode)))
#+end_src

** Markdown
Sometimes I need to edit Markdown documents, so this package is handy.
For markdown  mode I would like  to have automatic spell  checking and
filling. Basically  the same setup  as for Org  Mode.  And one  of the
features of Org mode is ability to edit source code blocks in separate
window  with  appropriate  major  mode.  This  can  be  achieved  with
=edit-indirect= package.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :config
    (defvar markdown-command "multimarkdown")
    (defun aorst/markdown-setup ()
      "Set buffer local variables."
      (setq fill-column 80
            default-justification 'left))
    :hook ((markdown-mode . flyspell-mode)
           (markdown-mode . auto-fill-mode)
           (markdown-mode . aorst/markdown-setup)))
#+end_src

** TOML
=toml-mode= helps  with highlighting of  TOML files, which Rust  uses to
configure project.

#+begin_src emacs-lisp
  (use-package toml-mode
    :bind (:map
           toml-mode-map
           ("C-c C-f" . aorst/indent-buffer)))
#+end_src

** Emacs Lisp
I write some  Emacs Lisp and experience is already  quite good, I just
want to enable some helper modes here.

#+begin_src emacs-lisp
  (use-package elisp-mode
    :ensure nil
    :hook (emacs-lisp-mode . eldoc-mode)
    :bind (:map
           emacs-lisp-mode-map
           ("C-c C-f" . aorst/indent-buffer)))
#+end_src

** Yaml
Support for =.yaml= files.

#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src

** Shell Script
Some configurations for shell script modes.

#+begin_src emacs-lisp
  (use-package sh-script
    :ensure nil
    :bind (:map
           sh-mode-map
           ("C-c C-f" . aorst/indent-buffer)))
#+end_src

** CSS

#+begin_src emacs-lisp
  (use-package css-mode
    :ensure nil
    :custom
    (css-indent-offset 2))
#+end_src

** python
I  use python  a lot  for  data science.  Here  I setup  a few  useful
packages to turn emacs into a python IDE.
** R
Installing ESS to work with R:

#+begin_src emacs-lisp
 (use-package ess
  :ensure t
  :init (load "ess-autoloads"))
#+end_src
** LSP
I need the language support packages. I am going with LSP.

#+begin_src emacs-lisp
;;(use-package lsp-python-ms
;;  :ensure t
;;  :hook (python-mode . (lambda ()
;;                       (require 'lsp-python-ms)
;;                      (lsp)))
;;)

(use-package lsp-mode
  :hook (;; replace XXX-mode with concrete major-mode(e. g. python-mode)
         (ess-mode . lsp)
         (python-mode . lsp)
         ;; if you want which-key integration
         (lsp-mode . lsp-enable-which-key-integration))
  :commands lsp)

;; LSP options
(use-package lsp-ui :commands lsp-ui-mode)
(use-package lsp-ivy :commands lsp-ivy-workspace-symbol)
(use-package lsp-treemacs :commands lsp-treemacs-errors-list)
(use-package which-key
  :config
  (which-key-mode))
#+end_src

* Tools
Additional  packages  that  change  how Emacs  works,  providing  more
comfortable user experience.

** Help
I want help  window to be selected automatically, so  I could close it
with =q= after I've finished reading.

#+begin_src emacs-lisp
  (use-package help
    :ensure nil
    :custom (help-window-select t))
#+end_src

** Doc View
Default resolution is too low:

#+begin_src emacs-lisp
  (use-package doc-view
    :ensure nil
    :custom (doc-view-resolution 192))
#+end_src

** vterm
This  package provides  a bridge  to =libvterm=  to display  terminal as
Emacs buffer. It works much better than =ansi-term=, though may be buggy
and requires compilation.

#+begin_src emacs-lisp
  (setq use-package-hook-name-suffix "-functions")
  (when (bound-and-true-p module-file-suffix)
    (use-package vterm
      :bind (("C-`" . aorst/vterm-toggle)
             ("C-t" . aorst/vterm-focus))
      :hook (vterm-exit . aorst/kill-vterm)
      :config
      (defun aorst/vterm-toggle (&optional arg)
        "Toggle `vterm' window on and off with the same command."
        (interactive "P")
        (let* ((directory (if default-directory
                              default-directory
                            (expand-file-name "~/")))
               (bufname "*vterm*")
               (window (get-buffer-window bufname)))
          (if window
              (ignore-errors (delete-window window))
            (if (window-dedicated-p)
                (let ((windows (seq-drop-while #'window-dedicated-p (window-list))))
                  (when (not (null windows))
                    (select-window (car windows)))))
            (let* ((win-side (if (symbolp arg)
                                 (cons (split-window-below) 'bot)
                               (cons (split-window-right) 'right)))
                   (window (car win-side))
                   (side (cdr win-side)))
              (select-window window)
              (cond ((get-buffer bufname)
                     (switch-to-buffer bufname))
                    (t (let ((default-directory directory))
                         (vterm bufname))))
              (when (bound-and-true-p global-tab-line-mode)
                (setq tab-line-format nil))
              (set-window-dedicated-p window t)
              (set-window-parameter window 'no-delete-other-windows t)
              (set-window-parameter window 'window-side side)
              (set-window-parameter window 'no-other-window t)))))
      (defun aorst/vterm-focus (&optional arg)
        "Focus `vterm' or open one if there's none."
        (interactive "P")
        (let ((window (get-buffer-window "*vterm*")))
          (if window
              (select-window window)
            (aorst/vterm-toggle arg))))
      (defun aorst/kill-vterm (buf &optional event)
        "Kill the `*vterm*' buffer after shell exits."
        (when buf (kill-buffer buf)))))
  (setq use-package-hook-name-suffix "-hook")
#+end_src

** EditorConfig
=.editorconfig=  file  provides a  nice  way  to synchronize  my  editor
configurations between projects and different editors.

#+begin_src emacs-lisp
  (use-package editorconfig
    :commands editorconfig-mode
    :config (editorconfig-mode 1))
#+end_src

** Flymake Mode
This mode allows checking syntax in  the buffer.  I was using [[https://www.flycheck.org/en/latest/][Flycheck]]
package  before,  but  I  don't   see  major  advantages  of  Flycheck
supporting 50  languages versus  4 in Flymake  [[https://www.flycheck.org/en/latest/user/flycheck-versus-flymake.html#supported-languages][(1)]], because  I'm using
language server protocol that integrates with Flymake, so as long as I
have  server for  a  language, I  have support  for  this language  in
Flymake.

Also let's  use right  fringe for indication  of errors  and warnings,
since it's never used, and left fringe is occupied by diff status.

#+begin_src emacs-lisp
  (use-package flymake
    :ensure nil
    :custom
    (flymake-fringe-indicator-position 'right-fringe)
    :config
    (remove-hook 'flymake-diagnostic-functions 'flymake-proc-legacy-flymake))
#+end_src

** Hydra
This is something like ability to create mappings that sit in it's own
mode, like different user modes in Kakoune. It allows me to press some
shortcut  and be  locked  in a  mode-like state  where  keys that  are
related  to  this  prefix  shortcut  are behaving  in  terms  of  this
shortcut.

This  package will  be used  in many  other package  configurations to
provide sane keybindings.

#+begin_src emacs-lisp
  (use-package hydra)
#+end_src

** Flx
Flex matching for Emacs.

#+begin_src emacs-lisp
  (use-package flx)
#+end_src

** Ivy and Counsel
Ivy  is a  narrowing  framework  like Helm,  but  much  lighter in  my
experience.  It  integrates with  Counsel that handles  minibuffer, so
let's install it too.

#+begin_src emacs-lisp
  (use-package ivy
    :commands ivy-mode
    :hook ((minibuffer-setup-hook . aorst/minibuffer-defer-garbage-collection)
           (minibuffer-exit-hook . aorst/minibuffer-restore-garbage-collection))
    :bind (("C-x b" . ivy-switch-buffer))
    :custom
    (ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
    (ivy-count-format "")
    (ivy-ignore-buffers '("\\` " "\\`\\*"))
    (ivy-display-style nil)
    (ivy-minibuffer-faces nil)
    (ivy-minibuffer-faces '(default default default default))
    (ivy-use-virtual-buffers t)
    (enable-recursive-minibuffers t)
    :init
    (defun aorst/minibuffer-defer-garbage-collection ()
      "Defer garbage collection for minibuffer"
      (setq gc-cons-threshold most-positive-fixnum))
    (defun aorst/minibuffer-restore-garbage-collection ()
      "Resotre garbage collection settings."
      (run-at-time
       1 nil (lambda () (setq gc-cons-threshold aorst--gc-cons-threshold))))
    (ivy-mode 1))
#+end_src

I'm using  [[https://github.com/sharkdp/fd][fd]] as a  great replacement for GNU  Find. It's fast  and it
takes  =.gitignore= into  account.  Counsel  has nice  =counsel-file-fump=
command that uses =find-program= variable, so  we can advice it in order
for it to use  =fd=. The same thing is for =rg=,  but counsel actually has
it's own variable for it, so we do no need to runtime-patch it.

#+begin_src emacs-lisp
  (use-package counsel
    :commands (counsel-M-x
               counsel-find-file
               counsel-file-jump
               counsel-recentf
               counsel-rg
               counsel-describe-function
               counsel-describe-variable
               counsel-find-library)
    :bind (("M-x" . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("C-x f" . counsel-file-jump)
           ("C-x C-r" . counsel-recentf)
           ("C-x d" . counsel-dired)
           ("C-h f" . counsel-describe-function)
           ("C-h C-f" . counsel-describe-face)
           ("C-h v" . counsel-describe-variable)
           ("C-h l" . counsel-find-library)
           ("C-x C-b" . counsel-switch-buffer))
    :config
    (when (executable-find "fd")
      (define-advice counsel-file-jump (:around (foo &optional initial-input initial-directory))
        (let ((find-program "fd")
              (counsel-file-jump-args (split-string "-L --type f --hidden")))
          (funcall foo))))
    (when (executable-find "rg")
      (setq counsel-rg-base-command
            "rg -S --no-heading --hidden --line-number --color never %s .")
      (setenv "FZF_DEFAULT_COMMAND"
              "rg --files --hidden --follow --no-ignore --no-messages --glob '!.git/*' --glob '!.svn/*'")))
#+end_src

** Ivy Posframe
This package displays =ivy= in separate frame on top of Emacs.

#+begin_src emacs-lisp
  (use-package ivy-posframe
    :after ivy
    :custom
    (ivy-posframe-display-functions-alist '((t . aorst/posframe-position)))
    (ivy-posframe-height-alist '((t . 16)))
    (ivy-posframe-parameters '((internal-border-width . 6)))
    (ivy-posframe-width 78)
    :config
    (defvar aorst--ivy-posframe-top-padding 42
      "additional padding between top of the frame and posframe.")
    (defun aorst/posframe-position (str)
      (ivy-posframe--display str #'aorst/posframe-under-tabs-center))
    (defun aorst/posframe-under-tabs-center (info)
      "Function that sets center position for ivy posframe."
      (cons (/ (- (plist-get info :parent-frame-width)
                  (plist-get info :posframe-width))
               2)
            0))
    (set-face-attribute 'ivy-posframe nil :background (face-attribute 'mode-line :background))
    (ivy-posframe-mode +1))

#+end_src

** Company
Complete anything framework. Nothing much to say. Does it's job.

#+begin_src emacs-lisp
  (use-package company
    :bind (:map
           company-active-map
           ("TAB" . company-complete-common-or-cycle)
           ("<tab>" . company-complete-common-or-cycle)
           ("<S-Tab>" . company-select-previous)
           ("<backtab>" . company-select-previous)
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous))
    :hook (after-init . global-company-mode)
    :custom
    (company-require-match 'never)
    (company-minimum-prefix-length 1)
    (company-tooltip-align-annotations t)
    (company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
                         company-preview-frontend
                         company-echo-metadata-frontend))
    (company-backends '(company-capf company-files))
    (company-tooltip-minimum-width 30)
    (company-tooltip-maximum-width 60)
    (company-idle-delay 0.0))
#+end_src

This package also optionally requires these extra dependencies:

- =company-posframe= - provides posframe frontend for company.

#+begin_src emacs-lisp
  (use-package company-posframe
    :after company
    :custom
    (company-posframe-quickhelp-show-header nil)
    (company-posframe-show-indicator nil)
    (company-posframe-show-metadata nil)
    (company-posframe-quickhelp-show-params
     (list :poshandler #'company-posframe-quickhelp-right-poshandler
           :internal-border-width 1
           :timeout 60
           :internal-border-color (face-attribute 'mode-line-inactive :background)
           :no-properties nil
           :poshandler nil))
    :config
    (company-posframe-mode))
#+end_src

** Undo Tree
This is more familiar  undo mode. It adds =C-/= mapping  to undo and =C-?=
mapping to redo.

#+begin_src emacs-lisp
  (use-package undo-tree
    :commands global-undo-tree-mode
    :init (global-undo-tree-mode 1))
#+end_src

** Magit
Emacs interface to Git.  I've heard that it has many nice features, so
I want to try it out.

#+begin_src emacs-lisp
  (use-package magit
    :hook ((git-commit-mode . flyspell-mode))
    :bind (("<f12>" . magit-status))
    :custom (magit-ediff-dwim-show-on-hunks t))
#+end_src

** Ediff
This is a built  in mode for diffing files in  Emacs. Previously I was
using  [[https://github.com/justbur/emacs-vdiff][Vdiff]] but  I have  to say  that I've  used it  so rarely,  so I
decided to avoid extra dependency and configure Ediff.

#+begin_src emacs-lisp
  (use-package ediff
    :ensure nil
    :hook ((ediff-before-setup . aorst/store-pre-ediff-winconfig)
           (ediff-quit . aorst/restore-pre-ediff-winconfig)
           (ediff-keymap-setup . aorst/ediff-setup-keys))
    :config
    (advice-add 'ediff-window-display-p :override #'ignore)
    :custom
    (ediff-split-window-function 'split-window-horizontally)
    :init
    (defvar aorst--ediff-last-windows nil
      "Stores window configuration before `ediff' was invoked.")
    (defun aorst/store-pre-ediff-winconfig ()
      (setq aorst--ediff-last-windows (current-window-configuration)))
    (defun aorst/restore-pre-ediff-winconfig ()
      (set-window-configuration aorst--ediff-last-windows))
    (defun aorst/ediff-copy-both-to-C ()
      (interactive)
      (ediff-copy-diff ediff-current-difference nil 'C nil
                       (concat
                        (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
                        (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
    (defun aorst/ediff-setup-keys ()
      (define-key ediff-mode-map "d" #'aorst/ediff-copy-both-to-C)))
#+end_src

** Multiple Cursors
This  package provides  multiple cursors  functionality to  Emacs.  It
isn't much like Kakoune's multiple selections, but anything will do. I
guess I'll figure out best mappings over time.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :commands (mc/cycle-backward
               mc/cycle-forward)
    :bind (("S-<mouse-1>" . mc/add-cursor-on-click)
           ("C-c m" . hydrant/mc/body)
           :map
           mc/keymap
           ("<return>" . nil))
    :requires hydra
    :config
    (defhydra hydrant/mc (:hint nil :color pink)
      "
   ^Select^                 ^Discard^                     ^Edit^               ^Navigate^
  ─^──────^─────────────────^───────^─────────────────────^────^───────────────^────────^─────────
   _M-s_: split lines       _M-SPC_:  discard current      _&_: align           _(_: cycle backward
   _s_:   select regexp     _b_:      discard blank lines  _#_: insert numbers  _)_: cycle forward
   _n_:   select next       _d_:      remove duplicated    ^ ^                  ^ ^
   _p_:   select previous   _q_ or _g_: exit hydrant       ^ ^                  ^ ^
   _C_:   select next line  _G_:      exit mc mode"
      ("M-s" mc/edit-ends-of-lines)
      ("s" mc/mark-all-in-region-regexp)
      ("n" mc/mark-next-like-this-word)
      ("p" mc/mark-previous-like-this-word)
      ("&" mc/vertical-align-with-space)
      ("(" mc/cycle-backward)
      (")" mc/cycle-forward)
      ("M-SPC" mc/remove-current-cursor)
      ("b" mc/remove-cursors-on-blank-lines)
      ("d" mc/remove-duplicated-cursors)
      ("C" mc/mark-next-lines)
      ("#" mc/insert-numbers)
      ("q" mc/remove-duplicated-cursors :exit t)
      ("g" mc/remove-duplicated-cursors :exit t)
      ("G" mc/keyboard-quit :exit t)))
  (use-package mc-extras)
#+end_src

** Expand Region
Expand  or   reduce  region  selection  semantically.   Supports  most
languages that I work with inside Emacs.

#+begin_src emacs-lisp
  (use-package expand-region
    :bind (("C-c e" . hydrant/er/body))
    :requires hydra
    :config
    (defhydra hydrant/er (:color pink :hint nil)
      "
   ^Expand/Discard^                ^Mark^
  ─^──────────────^────────────────^────^─────────────────
   _e_ or _+_: expand region         _(_:      inside pairs
   _r_ or _-_: reduce region         _)_:      around pairs
   _g_:      exit hydrant          _q_ or _'_: inside quotes
   _G_:      discard region, exit  _Q_ or _\"_: around quotes
   ^ ^    ^ ^                        _p_:      paragraph"
      ("e" er/expand-region)
      ("+" er/expand-region)
      ("r" er/contract-region)
      ("-" er/contract-region)
      ("p" er/mark-paragraph)
      ("(" er/mark-inside-pairs)
      (")" er/mark-outside-pairs)
      ("q" er/mark-inside-quotes)
      ("'" er/mark-inside-quotes)
      ("Q" er/mark-outside-quotes)
      ("\"" er/mark-outside-quotes)
      ("g" ignore :exit t)
      ("G" #'(lambda () (interactive) (deactivate-mark)) :exit t)))
#+end_src

** Iedit Mode
Another package  for multiple editing  purposes, that is  kinda faster
than multiple cursors,  but can edit only fixed width  regions of text
and  has less  abilities regarding  to commands.  Still pretty  usable
though, as multiple cursor some times looses cursors for some reason.

#+begin_src emacs-lisp
  (use-package iedit
    :bind (("M-n" . aorst/iedit-current-or-expand)
           ("C-c i" . aorst/iedit-hydrant))
    :custom
    (iedit-toggle-key-default nil)
    :init
    (defun aorst/iedit-to-mc-hydrant ()
      "Calls `iedit-to-mc-mode' and opens hydra for multiple cursors."
      (interactive)
      (iedit-switch-to-mc-mode)
      (hydrant/mc/body))
    (defun aorst/iedit-current-or-expand (&optional arg)
      "Select only currnent occurrence with `iedit-mode'.  Expand to
    next occurrence if `iedit-mode' is already active."
      (interactive "P")
      (if (bound-and-true-p iedit-mode)
          (if (symbolp arg)
              (iedit-expand-down-to-occurrence)
            (iedit-expand-up-to-occurrence))
        (iedit-mode 1)))
    (defun aorst/iedit-hydrant ()
      "toggle iedit mode for item under point, and open `hydrant/iedit'."
      (interactive)
      (ignore-errors
        (iedit-mode 1)
        (hydrant/iedit/body)))
    (defhydra hydrant/iedit (:hint nil :color pink)
      "
   ^Select^                  ^Discard^                   ^Edit^               ^Navigate^
  ─^──────^──────────────────^───────^───────────────────^────^───────────────^────────^─────────────
   _n_: next occurrence      _M-SPC_:  toggle selection  _u_: uppercase       _(_: previous selection
   _p_: previous occurrence  _q_ or _g_: exit hydrant      _d_: downcase        _)_: next selection
   ^ ^                       _G_:      exit iedit-mode   _#_: insert numbers
   ^ ^                       _m_:      switch to mc"
      ("n" iedit-expand-down-to-occurrence)
      ("m" aorst/iedit-to-mc-hydrant :exit t)
      ("p" iedit-expand-up-to-occurrence)
      ("u" iedit-upcase-occurrences)
      ("d" iedit-downcase-occurrences)
      ("#" iedit-number-occurrences)
      ("(" iedit-prev-occurrence)
      (")" iedit-next-occurrence)
      ("M-SPC" iedit-toggle-selection)
      ("q" ignore :exit t)
      ("g" ignore :exit t)
      ("G" #'(lambda () (interactive) (iedit-mode -1)) :exit t)))
#+end_src

** Server
I'm using  =server-start= command not because  I do not want  to load my
Emacs every time, but because I  want to have single instance of Emacs
running at a time, so all files that I open from GUI will be opened in
existing Emacs. If no Emacs exist, it should start one, start a server
and open a file.

#+begin_src emacs-lisp
  (use-package server
    :ensure nil
    :config
    (unless (server-running-p)
      (server-start)))
#+end_src

To fully achieve this behavior one needs a =.desktop= file to exist that
will decide which kind of Emacs to call: =emacs= or =emacsclient=:

#+begin_src conf-xdefaults :tangle ~/.local/share/applications/emacs.desktop :mkdirp yes :results silent
  [Desktop Entry]
  Name=Emacs
  GenericName=Text Editor
  Comment=Edit text
  MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
  Exec=sh -c "emacsclient -a emacs -n \"\$@\" || emacs" dummy %F
  Icon=emacs
  Type=Application
  Terminal=false
  Categories=Development;TextEditor;Utility;
  StartupWMClass=Emacs
#+end_src

This code above automatically creates user local =emacs.desktop= file in
=~/.local/share/applications= that will:

- call =emacs= if no arguments provided, or
- call =emacsclient  -a emacs= with  arguments. =emacsclient= will  try to
  connect to  a server,  and if  there's none, it  will fire  up =emacs=
  which will create server, and opening new files will be done in this
  instance of =emacs=.

** Hideshow
This built in mode provides code folding.

#+begin_src emacs-lisp
  (use-package hideshow
    :ensure nil
    :requires transient
    :hook (prog-mode . hs-minor-mode)
    :bind (:map prog-mode-map
                ("<f6>" . aorst/hideshow-menu))
    :config
    (define-transient-command aorst/hideshow-menu ()
      "Hideshow commands."
      [:description
       "Hide"
       ("ha" "all" hs-hide-all)
       ("hb" "block" hs-hide-block)]
      [:description
       "Show"
       ("sa" "all" hs-show-all)
       ("sb" "block" hs-show-block)]
      (interactive)
      (when (bound-and-true-p hs-minor-mode)
        (transient-setup 'aorst/hideshow-menu nil nil))))
#+end_src

** Saveplace
Save position in files you've visited.

#+begin_src emacs-lisp
  (use-package saveplace
    :ensure nil
    :init
    (save-place-mode))
#+end_src

** Edit Indirect
This  package  makes it  possible  to  edit  Markdown code  blocks  in
separate buffers.

#+begin_src emacs-lisp
  (use-package edit-indirect
    :hook ((edit-indirect-after-creation . aorst/real-buffer-setup)
           (edit-indirect-after-creation . aorst/edit-indirect-header-line-setup))
    :bind (:map
           edit-indirect-mode-map
           ("C-c C-c" . edit-indirect-commit)
           ("C-c C-k" . edit-indirect-abort)
           ("C-c '" . nil))
    :init
    (defun aorst/edit-indirect-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "\\<edit-indirect-mode-map>Edit, then exit with `\\[edit-indirect-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

** Separedit
This package  provides a way to  edit comments in sources  as separate
buffers with another major mode, like Markdown.

#+begin_src emacs-lisp
  (use-package separedit
    :hook (separedit-buffer-creation . aorst/separedit-header-line-setup)
    :bind (:map
           prog-mode-map
           ("C-c '" . separedit)
           :map edit-indirect-mode-map
           ("C-c '" . separedit))
    :custom
    (separedit-default-mode 'markdown-mode)
    :init
    (defun aorst/separedit-header-line-setup ()
      (setq-local
       header-line-format
       (substitute-command-keys
        "Edit, then exit with `\\[separedit-commit]' or abort with `\\[edit-indirect-abort]'"))))
#+end_src

** Recent files
Settings to =recentf= mode.

#+begin_src emacs-lisp
  (use-package recentf
    :ensure nil
    :config
    (add-to-list 'recentf-exclude "\\.gpg\\"))
#+end_src

* Postscript
#+begin_src emacs-lisp
  (provide 'init)
  ;;; init.el ends here
#+end_src
